// Auto-generated Ring extension
// Generated by parsec.ring
// Do not edit manually

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use ring_lang_rs::*;
use std::ffi::c_void;

use serde_json::{Value, Map};
use std::collections::HashMap;

// ============================================
// Basic JSON Operations
// ============================================

/// Parse a JSON string into internal representation
pub fn parse(json_str: &str) -> String {
    match serde_json::from_str::<Value>(json_str) {
        Ok(_) => "ok".to_string(),
        Err(e) => format!("error: {}", e),
    }
}

/// Check if a string is valid JSON
pub fn is_valid(json_str: &str) -> bool {
    serde_json::from_str::<Value>(json_str).is_ok()
}

/// Pretty print JSON with indentation
pub fn prettify(json_str: &str) -> String {
    match serde_json::from_str::<Value>(json_str) {
        Ok(v) => serde_json::to_string_pretty(&v).unwrap_or_default(),
        Err(e) => format!("error: {}", e),
    }
}

/// Minify JSON (remove whitespace)
pub fn minify(json_str: &str) -> String {
    match serde_json::from_str::<Value>(json_str) {
        Ok(v) => serde_json::to_string(&v).unwrap_or_default(),
        Err(e) => format!("error: {}", e),
    }
}

// ============================================
// Value Extraction (dot notation path)
// ============================================

/// Get a string value at path (e.g., "user.name" or "items.0.id")
pub fn get_string(json_str: &str, path: &str) -> String {
    get_value_at_path(json_str, path)
        .and_then(|v| v.as_str().map(|s| s.to_string()))
        .unwrap_or_default()
}

/// Get a number value at path
pub fn get_number(json_str: &str, path: &str) -> f64 {
    get_value_at_path(json_str, path)
        .and_then(|v| v.as_f64())
        .unwrap_or(0.0)
}

/// Get an integer value at path
pub fn get_int(json_str: &str, path: &str) -> i64 {
    get_value_at_path(json_str, path)
        .and_then(|v| v.as_i64())
        .unwrap_or(0)
}

/// Get a boolean value at path
pub fn get_bool(json_str: &str, path: &str) -> bool {
    get_value_at_path(json_str, path)
        .and_then(|v| v.as_bool())
        .unwrap_or(false)
}

/// Get a nested object/array as JSON string at path
pub fn get_json(json_str: &str, path: &str) -> String {
    get_value_at_path(json_str, path)
        .map(|v| serde_json::to_string(&v).unwrap_or_default())
        .unwrap_or_default()
}

/// Check if a path exists in JSON
pub fn has_path(json_str: &str, path: &str) -> bool {
    get_value_at_path(json_str, path).is_some()
}

/// Get the type of value at path ("string", "number", "boolean", "array", "object", "null", "undefined")
pub fn get_type(json_str: &str, path: &str) -> String {
    match get_value_at_path(json_str, path) {
        Some(v) => match v {
            Value::Null => "null",
            Value::Bool(_) => "boolean",
            Value::Number(_) => "number",
            Value::String(_) => "string",
            Value::Array(_) => "array",
            Value::Object(_) => "object",
        }.to_string(),
        None => "undefined".to_string(),
    }
}

// ============================================
// Array Operations
// ============================================

/// Get array length at path
pub fn array_len(json_str: &str, path: &str) -> i64 {
    get_value_at_path(json_str, path)
        .and_then(|v| v.as_array().map(|a| a.len() as i64))
        .unwrap_or(0)
}

/// Get array element at index (path can be empty for root array)
pub fn array_get(json_str: &str, path: &str, index: i64) -> String {
    let value = if path.is_empty() {
        serde_json::from_str::<Value>(json_str).ok()
    } else {
        get_value_at_path(json_str, path)
    };
    
    value
        .and_then(|v| v.as_array().cloned())
        .and_then(|a| a.get(index as usize).cloned())
        .map(|v| serde_json::to_string(&v).unwrap_or_default())
        .unwrap_or_default()
}

// ============================================
// Object Operations
// ============================================

/// Get all keys of an object at path (returns JSON array of strings)
pub fn object_keys(json_str: &str, path: &str) -> String {
    let value = if path.is_empty() {
        serde_json::from_str::<Value>(json_str).ok()
    } else {
        get_value_at_path(json_str, path)
    };
    
    value
        .and_then(|v| v.as_object().cloned())
        .map(|o| {
            let keys: Vec<&str> = o.keys().map(|s| s.as_str()).collect();
            serde_json::to_string(&keys).unwrap_or("[]".to_string())
        })
        .unwrap_or("[]".to_string())
}

/// Count keys in object at path
pub fn object_len(json_str: &str, path: &str) -> i64 {
    let value = if path.is_empty() {
        serde_json::from_str::<Value>(json_str).ok()
    } else {
        get_value_at_path(json_str, path)
    };
    
    value
        .and_then(|v| v.as_object().cloned())
        .map(|o| o.len() as i64)
        .unwrap_or(0)
}

// ============================================
// JSON Modification
// ============================================

/// Set a string value at path
pub fn set_string(json_str: &str, path: &str, value: &str) -> String {
    set_value_at_path(json_str, path, Value::String(value.to_string()))
}

/// Set a number value at path
pub fn set_number(json_str: &str, path: &str, value: f64) -> String {
    set_value_at_path(json_str, path, serde_json::Number::from_f64(value)
        .map(Value::Number)
        .unwrap_or(Value::Null))
}

/// Set a boolean value at path
pub fn set_bool(json_str: &str, path: &str, value: bool) -> String {
    set_value_at_path(json_str, path, Value::Bool(value))
}

/// Set null at path
pub fn set_null(json_str: &str, path: &str) -> String {
    set_value_at_path(json_str, path, Value::Null)
}

/// Set a JSON value at path (parses the value string as JSON)
pub fn set_json(json_str: &str, path: &str, value_json: &str) -> String {
    let value = serde_json::from_str::<Value>(value_json).unwrap_or(Value::Null);
    set_value_at_path(json_str, path, value)
}

/// Delete a key at path
pub fn delete_path(json_str: &str, path: &str) -> String {
    delete_at_path(json_str, path)
}

// ============================================
// JSON Building
// ============================================

/// Create an empty JSON object
pub fn new_object() -> String {
    "{}".to_string()
}

/// Create an empty JSON array
pub fn new_array() -> String {
    "[]".to_string()
}

/// Append value to array (value is JSON string)
pub fn array_push(json_str: &str, value_json: &str) -> String {
    let mut arr = serde_json::from_str::<Value>(json_str)
        .ok()
        .and_then(|v| if v.is_array() { Some(v) } else { None })
        .unwrap_or(Value::Array(vec![]));
    
    let value = serde_json::from_str::<Value>(value_json).unwrap_or(Value::Null);
    
    if let Value::Array(ref mut a) = arr {
        a.push(value);
    }
    
    serde_json::to_string(&arr).unwrap_or("[]".to_string())
}

/// Merge two JSON objects (second overwrites first on conflicts)
pub fn merge(json1: &str, json2: &str) -> String {
    let mut obj1 = serde_json::from_str::<Value>(json1)
        .ok()
        .and_then(|v| v.as_object().cloned())
        .unwrap_or_default();
    
    let obj2 = serde_json::from_str::<Value>(json2)
        .ok()
        .and_then(|v| v.as_object().cloned())
        .unwrap_or_default();
    
    for (k, v) in obj2 {
        obj1.insert(k, v);
    }
    
    serde_json::to_string(&Value::Object(obj1)).unwrap_or("{}".to_string())
}

// ============================================
// Helper Functions (not exposed to Ring)
// ============================================

fn get_value_at_path(json_str: &str, path: &str) -> Option<Value> {
    let root: Value = serde_json::from_str(json_str).ok()?;
    let parts: Vec<&str> = path.split('.').filter(|s| !s.is_empty()).collect();
    
    let mut current = &root;
    for part in parts {
        if let Ok(index) = part.parse::<usize>() {
            current = current.get(index)?;
        } else {
            current = current.get(part)?;
        }
    }
    Some(current.clone())
}

fn set_value_at_path(json_str: &str, path: &str, new_value: Value) -> String {
    let mut root: Value = match serde_json::from_str(json_str) {
        Ok(v) => v,
        Err(_) => return json_str.to_string(),
    };
    
    let parts: Vec<&str> = path.split('.').filter(|s| !s.is_empty()).collect();
    
    if parts.is_empty() {
        return serde_json::to_string(&new_value).unwrap_or_default();
    }
    
    let mut current = &mut root;
    for (i, part) in parts.iter().enumerate() {
        let is_last = i == parts.len() - 1;
        
        if is_last {
            if let Ok(index) = part.parse::<usize>() {
                if let Value::Array(ref mut arr) = current {
                    if index < arr.len() {
                        arr[index] = new_value.clone();
                    }
                }
            } else if let Value::Object(ref mut obj) = current {
                obj.insert(part.to_string(), new_value.clone());
            }
        } else {
            if let Ok(index) = part.parse::<usize>() {
                current = match current.get_mut(index) {
                    Some(v) => v,
                    None => return json_str.to_string(),
                };
            } else {
                current = match current.get_mut(*part) {
                    Some(v) => v,
                    None => return json_str.to_string(),
                };
            }
        }
    }
    
    serde_json::to_string(&root).unwrap_or(json_str.to_string())
}

fn delete_at_path(json_str: &str, path: &str) -> String {
    let mut root: Value = match serde_json::from_str(json_str) {
        Ok(v) => v,
        Err(_) => return json_str.to_string(),
    };
    
    let parts: Vec<&str> = path.split('.').filter(|s| !s.is_empty()).collect();
    
    if parts.is_empty() {
        return json_str.to_string();
    }
    
    if parts.len() == 1 {
        if let Value::Object(ref mut obj) = root {
            obj.remove(parts[0]);
        }
        return serde_json::to_string(&root).unwrap_or(json_str.to_string());
    }
    
    let mut current = &mut root;
    for (i, part) in parts.iter().enumerate() {
        let is_last = i == parts.len() - 1;
        
        if is_last {
            if let Ok(index) = part.parse::<usize>() {
                if let Value::Array(ref mut arr) = current {
                    if index < arr.len() {
                        arr.remove(index);
                    }
                }
            } else if let Value::Object(ref mut obj) = current {
                obj.remove(*part);
            }
        } else {
            if let Ok(index) = part.parse::<usize>() {
                current = match current.get_mut(index) {
                    Some(v) => v,
                    None => return json_str.to_string(),
                };
            } else {
                current = match current.get_mut(*part) {
                    Some(v) => v,
                    None => return json_str.to_string(),
                };
            }
        }
    }
    
    serde_json::to_string(&root).unwrap_or(json_str.to_string())
}

// ============================================
// Ring List <-> JSON Conversion (Manual ring_func!)
// ============================================

use std::ffi::c_int;

/// Convert Ring list to JSON Value recursively
fn ring_list_to_json(list: RingList) -> Value {
    let size = ring_list_getsize(list);
    
    // Check if it's an object (list of [key, value] pairs where all keys are strings)
    let mut is_object = size > 0;
    for i in 1..=size {
        if ring_list_islist(list, i) {
            let inner = ring_list_getlist(list, i);
            let inner_size = ring_list_getsize(inner);
            if inner_size != 2 || !ring_list_isstring(inner, 1) {
                is_object = false;
                break;
            }
        } else {
            is_object = false;
            break;
        }
    }
    
    if is_object {
        // Convert to JSON object
        let mut map = serde_json::Map::new();
        for i in 1..=size {
            let inner = ring_list_getlist(list, i);
            let key = ring_list_getstring(inner, 1);
            let key_str = unsafe { std::ffi::CStr::from_ptr(key).to_string_lossy().into_owned() };
            let value = ring_list_item_to_json(inner, 2);
            map.insert(key_str, value);
        }
        Value::Object(map)
    } else {
        // Convert to JSON array
        let mut arr = Vec::new();
        for i in 1..=size {
            arr.push(ring_list_item_to_json(list, i));
        }
        Value::Array(arr)
    }
}

/// Convert a single Ring list item to JSON Value
fn ring_list_item_to_json(list: RingList, index: u32) -> Value {
    if ring_list_isstring(list, index) {
        let s = ring_list_getstring(list, index);
        let rust_str = unsafe { std::ffi::CStr::from_ptr(s).to_string_lossy().into_owned() };
        Value::String(rust_str)
    } else if ring_list_isnumber(list, index) {
        // Try to get as int first, then fall back to double
        let i = ring_list_getint(list, index);
        let d = ring_list_getdouble(list, index);
        
        // If int and double representations are equivalent, use int
        if (i as f64 - d).abs() < 0.0001 {
            Value::Number(serde_json::Number::from(i as i64))
        } else {
            // It's a real floating point number
            serde_json::Number::from_f64(d)
                .map(Value::Number)
                .unwrap_or(Value::Null)
        }
    } else if ring_list_islist(list, index) {
        let inner = ring_list_getlist(list, index);
        ring_list_to_json(inner)
    } else {
        Value::Null
    }
}

/// Add a JSON value as an item to a Ring list
fn json_value_to_ring_list_item(p: *mut c_void, list: RingList, value: &Value) {
    match value {
        Value::Null => {
            ring_list_addstring_str(list, "null");
        }
        Value::Bool(b) => {
            ring_list_addint(list, if *b { 1 } else { 0 });
        }
        Value::Number(n) => {
            if let Some(i) = n.as_i64() {
                ring_list_addint(list, i as c_int);
            } else if let Some(f) = n.as_f64() {
                ring_list_adddouble(list, f);
            }
        }
        Value::String(s) => {
            ring_list_addstring_str(list, s);
        }
        Value::Array(arr) => {
            let inner = ring_list_newlist(list);
            for item in arr {
                json_value_to_ring_list_item(p, inner, item);
            }
        }
        Value::Object(obj) => {
            let inner = ring_list_newlist(list);
            for (key, val) in obj {
                let pair = ring_list_newlist(inner);
                ring_list_addstring_str(pair, key);
                json_value_to_ring_list_item(p, pair, val);
            }
        }
    }
}

/// Convert JSON Value to Ring list
fn json_to_ring_list(p: *mut c_void, value: &Value) -> RingList {
    let list = ring_api_newlist(p);
    match value {
        Value::Array(arr) => {
            for item in arr {
                json_value_to_ring_list_item(p, list, item);
            }
        }
        Value::Object(obj) => {
            for (key, val) in obj {
                let pair = ring_list_newlist(list);
                ring_list_addstring_str(pair, key);
                json_value_to_ring_list_item(p, pair, val);
            }
        }
        _ => {
            json_value_to_ring_list_item(p, list, value);
        }
    }
    list
}

// ============================================
// encode(list [, pretty]) - Convert Ring list to JSON string
// ============================================
ring_func!(ring_json_encode, |p| {
    let para_count = ring_api_paracount(p);
    if para_count < 1 || para_count > 2 {
        ring_error!(p, "encode() expects 1 or 2 parameters: (list [, pretty])");
        return;
    }
    
    if !ring_api_islist(p, 1) {
        ring_error!(p, "encode() first parameter must be a list");
        return;
    }
    
    let pretty = if para_count == 2 {
        if ring_api_isnumber(p, 2) {
            ring_api_getnumber(p, 2) != 0.0
        } else {
            false
        }
    } else {
        false
    };
    
    let list = ring_api_getlist(p, 1);
    let json_value = ring_list_to_json(list);
    
    let result = if pretty {
        serde_json::to_string_pretty(&json_value).unwrap_or_default()
    } else {
        serde_json::to_string(&json_value).unwrap_or_default()
    };
    
    ring_ret_string!(p, &result);
});

// ============================================
// decode(json_string) - Convert JSON string to Ring list
// ============================================
ring_func!(ring_json_decode, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);
    
    let json_str = ring_get_string!(p, 1);
    
    match serde_json::from_str::<Value>(json_str) {
        Ok(value) => {
            let list = json_to_ring_list(p, &value);
            ring_ret_list!(p, list);
        }
        Err(e) => {
            ring_error!(p, &format!("JSON parse error: {}", e));
        }
    }
});

// ============================================
// Function: parse
// ============================================
ring_func!(ring_json_parse, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = parse(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: is_valid
// ============================================
ring_func!(ring_json_is_valid, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = is_valid(__arg_1);
    ring_ret_number!(p, if __result { 1.0 } else { 0.0 });
});

// ============================================
// Function: prettify
// ============================================
ring_func!(ring_json_prettify, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = prettify(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: minify
// ============================================
ring_func!(ring_json_minify, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = minify(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: get_string
// ============================================
ring_func!(ring_json_get_string, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = get_string(__arg_1, __arg_2);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: get_number
// ============================================
ring_func!(ring_json_get_number, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = get_number(__arg_1, __arg_2);
    ring_ret_number!(p, __result as f64);
});

// ============================================
// Function: get_int
// ============================================
ring_func!(ring_json_get_int, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = get_int(__arg_1, __arg_2);
    ring_ret_number!(p, __result as f64);
});

// ============================================
// Function: get_bool
// ============================================
ring_func!(ring_json_get_bool, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = get_bool(__arg_1, __arg_2);
    ring_ret_number!(p, if __result { 1.0 } else { 0.0 });
});

// ============================================
// Function: get_json
// ============================================
ring_func!(ring_json_get_json, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = get_json(__arg_1, __arg_2);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: has_path
// ============================================
ring_func!(ring_json_has_path, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = has_path(__arg_1, __arg_2);
    ring_ret_number!(p, if __result { 1.0 } else { 0.0 });
});

// ============================================
// Function: get_type
// ============================================
ring_func!(ring_json_get_type, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = get_type(__arg_1, __arg_2);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: array_len
// ============================================
ring_func!(ring_json_array_len, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = array_len(__arg_1, __arg_2);
    ring_ret_number!(p, __result as f64);
});

// ============================================
// Function: array_get
// ============================================
ring_func!(ring_json_array_get, |p| {
    ring_check_paracount!(p, 3);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);
    ring_check_number!(p, 3);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);
    let __arg_3 = ring_get_number!(p, 3) as i64;

    let __result = array_get(__arg_1, __arg_2, __arg_3);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: object_keys
// ============================================
ring_func!(ring_json_object_keys, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = object_keys(__arg_1, __arg_2);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: object_len
// ============================================
ring_func!(ring_json_object_len, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = object_len(__arg_1, __arg_2);
    ring_ret_number!(p, __result as f64);
});

// ============================================
// Function: set_string
// ============================================
ring_func!(ring_json_set_string, |p| {
    ring_check_paracount!(p, 3);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);
    ring_check_string!(p, 3);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);
    let __arg_3 = ring_get_string!(p, 3);

    let __result = set_string(__arg_1, __arg_2, __arg_3);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: set_number
// ============================================
ring_func!(ring_json_set_number, |p| {
    ring_check_paracount!(p, 3);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);
    ring_check_number!(p, 3);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);
    let __arg_3 = ring_get_number!(p, 3) as f64;

    let __result = set_number(__arg_1, __arg_2, __arg_3);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: set_bool
// ============================================
ring_func!(ring_json_set_bool, |p| {
    ring_check_paracount!(p, 3);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);
    ring_check_number!(p, 3);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);
    let __arg_3 = ring_get_number!(p, 3) != 0.0;

    let __result = set_bool(__arg_1, __arg_2, __arg_3);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: set_null
// ============================================
ring_func!(ring_json_set_null, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = set_null(__arg_1, __arg_2);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: set_json
// ============================================
ring_func!(ring_json_set_json, |p| {
    ring_check_paracount!(p, 3);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);
    ring_check_string!(p, 3);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);
    let __arg_3 = ring_get_string!(p, 3);

    let __result = set_json(__arg_1, __arg_2, __arg_3);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: delete_path
// ============================================
ring_func!(ring_json_delete_path, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = delete_path(__arg_1, __arg_2);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: new_object
// ============================================
ring_func!(ring_json_new_object, |p| {
    ring_check_paracount!(p, 0);


    let __result = new_object();
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: new_array
// ============================================
ring_func!(ring_json_new_array, |p| {
    ring_check_paracount!(p, 0);


    let __result = new_array();
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: array_push
// ============================================
ring_func!(ring_json_array_push, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = array_push(__arg_1, __arg_2);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: merge
// ============================================
ring_func!(ring_json_merge, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = merge(__arg_1, __arg_2);
    ring_ret_string!(p, &__result);
});

// ============================================
// Library Registration
// ============================================
ring_libinit! {
    "json_parse" => ring_json_parse,
    "json_is_valid" => ring_json_is_valid,
    "json_prettify" => ring_json_prettify,
    "json_minify" => ring_json_minify,
    "json_get_string" => ring_json_get_string,
    "json_get_number" => ring_json_get_number,
    "json_get_int" => ring_json_get_int,
    "json_get_bool" => ring_json_get_bool,
    "json_get_json" => ring_json_get_json,
    "json_has_path" => ring_json_has_path,
    "json_get_type" => ring_json_get_type,
    "json_array_len" => ring_json_array_len,
    "json_array_get" => ring_json_array_get,
    "json_object_keys" => ring_json_object_keys,
    "json_object_len" => ring_json_object_len,
    "json_set_string" => ring_json_set_string,
    "json_set_number" => ring_json_set_number,
    "json_set_bool" => ring_json_set_bool,
    "json_set_null" => ring_json_set_null,
    "json_set_json" => ring_json_set_json,
    "json_delete_path" => ring_json_delete_path,
    "json_new_object" => ring_json_new_object,
    "json_new_array" => ring_json_new_array,
    "json_array_push" => ring_json_array_push,
    "json_merge" => ring_json_merge,
    "json_encode" => ring_json_encode,
    "json_decode" => ring_json_decode
}
