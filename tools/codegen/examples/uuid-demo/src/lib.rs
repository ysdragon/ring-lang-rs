// Auto-generated Ring extension
// Generated by parsec.ring
// Do not edit manually

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use ring_lang_rs::*;
use std::ffi::c_void;

use uuid::{Uuid, Timestamp, NoContext};
use hex;

// ============================================
// UUID Generation
// ============================================

/// Generate a random UUID v4
pub fn v4() -> String {
    Uuid::new_v4().to_string()
}

/// Generate a UUID v7 (time-ordered, random)
pub fn v7() -> String {
    Uuid::now_v7().to_string()
}

/// Generate a nil UUID (all zeros)
pub fn nil() -> String {
    Uuid::nil().to_string()
}

/// Generate a max UUID (all ones)
pub fn max() -> String {
    Uuid::max().to_string()
}

// ============================================
// UUID Parsing & Validation
// ============================================

/// Parse a UUID string (returns canonical format or empty on error)
pub fn parse(s: &str) -> String {
    Uuid::parse_str(s)
        .map(|u| u.to_string())
        .unwrap_or_default()
}

/// Check if string is a valid UUID
pub fn is_valid(s: &str) -> bool {
    Uuid::parse_str(s).is_ok()
}

/// Get UUID version (0 for nil, 4 for random, 7 for time-ordered, etc.)
pub fn get_version(s: &str) -> u32 {
    Uuid::parse_str(s)
        .map(|u| u.get_version_num() as u32)
        .unwrap_or(0)
}

/// Get UUID variant
pub fn get_variant(s: &str) -> String {
    Uuid::parse_str(s)
        .map(|u| format!("{:?}", u.get_variant()))
        .unwrap_or_default()
}

// ============================================
// UUID Formatting
// ============================================

/// Format UUID as lowercase hyphenated (canonical)
pub fn to_string(s: &str) -> String {
    Uuid::parse_str(s)
        .map(|u| u.hyphenated().to_string())
        .unwrap_or_default()
}

/// Format UUID as uppercase hyphenated
pub fn to_upper(s: &str) -> String {
    Uuid::parse_str(s)
        .map(|u| u.hyphenated().to_string().to_uppercase())
        .unwrap_or_default()
}

/// Format UUID without hyphens
pub fn to_simple(s: &str) -> String {
    Uuid::parse_str(s)
        .map(|u| u.simple().to_string())
        .unwrap_or_default()
}

/// Format UUID as URN (urn:uuid:...)
pub fn to_urn(s: &str) -> String {
    Uuid::parse_str(s)
        .map(|u| u.urn().to_string())
        .unwrap_or_default()
}

/// Format UUID as braced ({...})
pub fn to_braced(s: &str) -> String {
    Uuid::parse_str(s)
        .map(|u| u.braced().to_string())
        .unwrap_or_default()
}

// ============================================
// UUID Comparison
// ============================================

/// Check if two UUIDs are equal
pub fn equals(uuid1: &str, uuid2: &str) -> bool {
    match (Uuid::parse_str(uuid1), Uuid::parse_str(uuid2)) {
        (Ok(u1), Ok(u2)) => u1 == u2,
        _ => false,
    }
}

/// Check if UUID is nil (all zeros)
pub fn is_nil(s: &str) -> bool {
    Uuid::parse_str(s)
        .map(|u| u.is_nil())
        .unwrap_or(false)
}

/// Check if UUID is max (all ones)
pub fn is_max(s: &str) -> bool {
    Uuid::parse_str(s)
        .map(|u| u.is_max())
        .unwrap_or(false)
}

/// Compare two UUIDs (-1 if first < second, 0 if equal, 1 if first > second)
pub fn compare(uuid1: &str, uuid2: &str) -> i32 {
    match (Uuid::parse_str(uuid1), Uuid::parse_str(uuid2)) {
        (Ok(u1), Ok(u2)) => {
            if u1 < u2 { -1 }
            else if u1 > u2 { 1 }
            else { 0 }
        },
        _ => 0,
    }
}

// ============================================
// UUID Bytes
// ============================================

/// Get UUID as hex-encoded bytes (32 chars)
pub fn to_hex(s: &str) -> String {
    Uuid::parse_str(s)
        .map(|u| hex::encode(u.as_bytes()))
        .unwrap_or_default()
}

/// Create UUID from hex-encoded bytes
pub fn from_hex(hex_str: &str) -> String {
    hex::decode(hex_str)
        .ok()
        .and_then(|bytes: Vec<u8>| {
            if bytes.len() == 16 {
                let arr: [u8; 16] = bytes.try_into().ok()?;
                Some(Uuid::from_bytes(arr).to_string())
            } else {
                None
            }
        })
        .unwrap_or_default()
}

// ============================================
// Batch Generation
// ============================================

/// Generate multiple v4 UUIDs (returns JSON array)
pub fn batch_v4(count: u32) -> String {
    let uuids: Vec<String> = (0..count).map(|_| Uuid::new_v4().to_string()).collect();
    format!("[{}]", uuids.iter().map(|u| format!("\"{}\"", u)).collect::<Vec<_>>().join(","))
}

/// Generate multiple v7 UUIDs (returns JSON array)
pub fn batch_v7(count: u32) -> String {
    let uuids: Vec<String> = (0..count).map(|_| Uuid::now_v7().to_string()).collect();
    format!("[{}]", uuids.iter().map(|u| format!("\"{}\"", u)).collect::<Vec<_>>().join(","))
}

// ============================================
// UUID v7 Timestamp Extraction
// ============================================

/// Extract Unix timestamp (milliseconds) from v7 UUID
pub fn v7_timestamp_ms(s: &str) -> i64 {
    Uuid::parse_str(s)
        .ok()
        .and_then(|u| {
            if u.get_version_num() == 7 {
                u.get_timestamp().map(|ts| {
                    let (secs, nanos) = ts.to_unix();
                    (secs as i64) * 1000 + (nanos as i64 / 1_000_000)
                })
            } else {
                None
            }
        })
        .unwrap_or(0)
}

/// Create v7 UUID from Unix timestamp (milliseconds)
pub fn v7_from_timestamp_ms(timestamp_ms: i64) -> String {
    let secs = (timestamp_ms / 1000) as u64;
    let nanos = ((timestamp_ms % 1000) * 1_000_000) as u32;
    let ts = Timestamp::from_unix(NoContext, secs, nanos);
    Uuid::new_v7(ts).to_string()
}

// ============================================
// Function: v4
// ============================================
ring_func!(ring_uuid_v4, |p| {
    ring_check_paracount!(p, 0);


    let __result = v4();
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: v7
// ============================================
ring_func!(ring_uuid_v7, |p| {
    ring_check_paracount!(p, 0);


    let __result = v7();
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: nil
// ============================================
ring_func!(ring_uuid_nil, |p| {
    ring_check_paracount!(p, 0);


    let __result = nil();
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: max
// ============================================
ring_func!(ring_uuid_max, |p| {
    ring_check_paracount!(p, 0);


    let __result = max();
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: parse
// ============================================
ring_func!(ring_uuid_parse, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = parse(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: is_valid
// ============================================
ring_func!(ring_uuid_is_valid, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = is_valid(__arg_1);
    ring_ret_number!(p, if __result { 1.0 } else { 0.0 });
});

// ============================================
// Function: get_version
// ============================================
ring_func!(ring_uuid_get_version, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = get_version(__arg_1);
    ring_ret_number!(p, __result as f64);
});

// ============================================
// Function: get_variant
// ============================================
ring_func!(ring_uuid_get_variant, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = get_variant(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: to_string
// ============================================
ring_func!(ring_uuid_to_string, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = to_string(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: to_upper
// ============================================
ring_func!(ring_uuid_to_upper, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = to_upper(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: to_simple
// ============================================
ring_func!(ring_uuid_to_simple, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = to_simple(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: to_urn
// ============================================
ring_func!(ring_uuid_to_urn, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = to_urn(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: to_braced
// ============================================
ring_func!(ring_uuid_to_braced, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = to_braced(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: equals
// ============================================
ring_func!(ring_uuid_equals, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = equals(__arg_1, __arg_2);
    ring_ret_number!(p, if __result { 1.0 } else { 0.0 });
});

// ============================================
// Function: is_nil
// ============================================
ring_func!(ring_uuid_is_nil, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = is_nil(__arg_1);
    ring_ret_number!(p, if __result { 1.0 } else { 0.0 });
});

// ============================================
// Function: is_max
// ============================================
ring_func!(ring_uuid_is_max, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = is_max(__arg_1);
    ring_ret_number!(p, if __result { 1.0 } else { 0.0 });
});

// ============================================
// Function: compare
// ============================================
ring_func!(ring_uuid_compare, |p| {
    ring_check_paracount!(p, 2);
    ring_check_string!(p, 1);
    ring_check_string!(p, 2);

    let __arg_1 = ring_get_string!(p, 1);
    let __arg_2 = ring_get_string!(p, 2);

    let __result = compare(__arg_1, __arg_2);
    ring_ret_number!(p, __result as f64);
});

// ============================================
// Function: to_hex
// ============================================
ring_func!(ring_uuid_to_hex, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = to_hex(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: from_hex
// ============================================
ring_func!(ring_uuid_from_hex, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = from_hex(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: batch_v4
// ============================================
ring_func!(ring_uuid_batch_v4, |p| {
    ring_check_paracount!(p, 1);
    ring_check_number!(p, 1);

    let __arg_1 = ring_get_number!(p, 1) as u32;

    let __result = batch_v4(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: batch_v7
// ============================================
ring_func!(ring_uuid_batch_v7, |p| {
    ring_check_paracount!(p, 1);
    ring_check_number!(p, 1);

    let __arg_1 = ring_get_number!(p, 1) as u32;

    let __result = batch_v7(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: v7_timestamp_ms
// ============================================
ring_func!(ring_uuid_v7_timestamp_ms, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = v7_timestamp_ms(__arg_1);
    ring_ret_number!(p, __result as f64);
});

// ============================================
// Function: v7_from_timestamp_ms
// ============================================
ring_func!(ring_uuid_v7_from_timestamp_ms, |p| {
    ring_check_paracount!(p, 1);
    ring_check_number!(p, 1);

    let __arg_1 = ring_get_number!(p, 1) as i64;

    let __result = v7_from_timestamp_ms(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Library Registration
// ============================================
ring_libinit! {
    b"uuid_v4\0" => ring_uuid_v4,
    b"uuid_v7\0" => ring_uuid_v7,
    b"uuid_nil\0" => ring_uuid_nil,
    b"uuid_max\0" => ring_uuid_max,
    b"uuid_parse\0" => ring_uuid_parse,
    b"uuid_is_valid\0" => ring_uuid_is_valid,
    b"uuid_get_version\0" => ring_uuid_get_version,
    b"uuid_get_variant\0" => ring_uuid_get_variant,
    b"uuid_to_string\0" => ring_uuid_to_string,
    b"uuid_to_upper\0" => ring_uuid_to_upper,
    b"uuid_to_simple\0" => ring_uuid_to_simple,
    b"uuid_to_urn\0" => ring_uuid_to_urn,
    b"uuid_to_braced\0" => ring_uuid_to_braced,
    b"uuid_equals\0" => ring_uuid_equals,
    b"uuid_is_nil\0" => ring_uuid_is_nil,
    b"uuid_is_max\0" => ring_uuid_is_max,
    b"uuid_compare\0" => ring_uuid_compare,
    b"uuid_to_hex\0" => ring_uuid_to_hex,
    b"uuid_from_hex\0" => ring_uuid_from_hex,
    b"uuid_batch_v4\0" => ring_uuid_batch_v4,
    b"uuid_batch_v7\0" => ring_uuid_batch_v7,
    b"uuid_v7_timestamp_ms\0" => ring_uuid_v7_timestamp_ms,
    b"uuid_v7_from_timestamp_ms\0" => ring_uuid_v7_from_timestamp_ms
}
